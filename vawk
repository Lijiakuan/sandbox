#!/usr/bin/env python

import argparse, sys, re
from argparse import RawTextHelpFormatter
from subprocess import Popen, PIPE, STDOUT

__author__ = "Colby Chiang (cc2qe@virginia.edu)"
__version__ = "$Revision: 0.0.1 $"
__date__ = "$Date: 2014-05-22 16:59 $"

# --------------------------------------
# define functions

def get_args():
    parser = argparse.ArgumentParser(formatter_class=RawTextHelpFormatter,
                                     add_help=True, description="\
vawk\n\
author: " + __author__ + "\n\
version: " + __version__ + "\n\
description: An awk-like VCF parser")
    #parser.add_argument('-a', '--argA', metavar='argA', type=str, required=True, help='description of argument')
    #parser.add_argument('-b', '--argB', metavar='argB', required=False, help='description of argument B')
    #parser.add_argument('-c', '--flagC', required=False, action='store_true', help='sets flagC to true')
    #parser.add_argument('--help', required=False, action=parser.print_help(), help='show this help message and exit')
    parser.add_argument('--debug', action='store_true', help='debugging level verbosity')
    parser.add_argument('-v', '--var', required=False, type=str, help='declare an external variable')
    parser.add_argument('--header', required=False, action='store_true', help='print VCF header')
    parser.add_argument('vawk_string', nargs=1, help='vawk string')
    parser.add_argument('vcf', nargs='?', type=str, default=None, help='VCF file (default: stdin)')

    # parse the arguments
    args = parser.parse_args()

    # if args.help:
    #     parser.print_help()
    #     exit(1)

    # if no input, check if part of pipe and if so, read stdin.
    if args.vcf == None:
        if sys.stdin.isatty():
            parser.print_help()
            exit(1)
        else:
            args.vcf = '-'

    # send back the user input
    return args

# parse the vawk string into BEGIN PER-LINE and END portions
def parse(raw):
    begin = ''
    perline = ''
    end = ''
    op_brace = 0
    b = 0
    a = 0
    begin_idx = [0,-1]
    end_idx = [0,-1]

    # get BEGIN script
    try:
        begin_idx[0] = re.search(r'BEGIN\s*{', raw).start()
        a = begin_idx[0] + 5
        b = a
        while begin == '':
            if raw[b] == '{':
                op_brace += 1
            elif raw[b] == '}':
                op_brace -= 1
                if op_brace == 0:
                    begin = raw[a:b+1].strip()[1:-1]
                    begin_idx[1] = b
                    break
            b += 1
    except AttributeError:
        pass
    raw = raw[:begin_idx[0]] + raw[begin_idx[1]+1:]

    # get END script
    try:
        end_idx[0] = re.search(r'END\s*{', raw).start()
        a = re.search(r'END\s*{', raw).start() + 3
        b = a
        while end == '':
            if raw[b] == '{':
                op_brace += 1
            elif raw[b] == '}':
                op_brace -= 1
                if op_brace == 0:
                    end = raw[a:b+1].strip()[1:-1]
                    end_idx[1] = b
                    break
            b += 1
    except AttributeError:
        pass
    raw = raw[:end_idx[0]] + raw[end_idx[1]+1:]

    # get PER-LINE script (remainder of string)
    perline = raw.strip()
    if perline.startswith('{') and perline.endswith('}'):
        perline = perline[1:-1]
    else:
        perline = 'if (' + perline + ') print ; '

    return (begin, perline, end)

# primary function
def vawk(header, vawk_string, vcf_file, debug):
    # parse the vawk string in to BEGIN, END, and PERLINE
    (begin, perline, end) = parse(vawk_string[0])

    if debug:
        print 'begin:', begin
        print 'perline:', perline
        print 'end:', end

    # get the requested info keys from the command line (format: INFO$FIELD)
    info_keys = set(re.findall(r'INFO\$([^\W]*)', perline))

    if re.search('INFO\$',perline):
        # split and parse the relevant INFO fields
        perline = 'split($8,x,";"); for (i=1; i<=length(x); ++i) { ' \
                  + ' '.join(['if (x[i]~"^' + mykey + '=" || x[i]=="' + mykey + '") { split(x[i],info,"="); if (length(info)==1) { INFO_' + mykey + '=1} else {INFO_' + mykey + '=info[2]} }' for mykey in info_keys]) \
                  + '} ' \
                  + perline
        # replace the toxic $ in the awk command
        for mykey in info_keys:
            perline = re.sub('INFO\$' + mykey, 'INFO_' + mykey, perline)
        
    # only print the header if requested
    if header:
        perline = 'if ($0~"^#") {print} else {' + perline + '}'
    else:
        perline = 'if ($0~"^#") {next} else {' + perline + '}'

    vawk_string = 'BEGIN {FS="\t"; OFS="\t"; ' + begin + '}' + ' {' + perline + '} ' + 'END {' + end + '}'

    cmd = ['awk', vawk_string, vcf_file]
    if debug:
        print cmd
    
    #print subprocess.check_output(['echo', 'Hello World'])
    #subprocess.check_output(["echo", "Hello World!"])
    p = Popen(cmd, stdout=PIPE, stderr=STDOUT)

    for line in iter(p.stdout.readline, b''):
       print line.rstrip()


    
    # for line in vcf:
    #     if header or line[0] != '#':
    #         print line.rstrip()

    # close the input file
    # vcf.close()

    return

# --------------------------------------
# main function

def main():
    # parse the command line args
    args = get_args()

    # call primary function
    vawk(args.header, args.vawk_string, args.vcf, args.debug)

# initialize the script
if __name__ == '__main__':
    try:
        sys.exit(main())
    except IOError, e:
        if e.errno != 32:  # ignore SIGPIPE
            raise





